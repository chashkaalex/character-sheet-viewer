<script>

/**
 * Converts duration from various time units to rounds
 * @param {number} duration - The duration value
 * @param {string} unit - The time unit ('rounds', 'minutes', or 'hours')
 * @returns {number} - Duration in rounds
 */
function convertToRounds(duration, unit) {
  switch (unit) {
  case 'rounds':
    return duration;
  case 'minutes':
    return duration * 6; // 1 minute = 6 rounds
  case 'hours':
    return duration * 360; // 1 hour = 60 minutes = 360 rounds
  default:
    return duration; // Default to rounds if unknown unit
  }
}

function NewStatus() {
  console.log('NewStatus for ' + characterRep.name);
  const statusesList = document.getElementById('statusesList');
  const emptyStatus = document.getElementById('emptyStatus');
  const clone = emptyStatus.cloneNode(true);
  clone.id = ''; // Clear the ID to avoid duplicates
  statusesList.insertBefore(clone, emptyStatus);

  clone.querySelector('.status-name-input').style.display = 'inline-block';
  clone.querySelector('.timed-controls').style.display = 'inline-flex';
  clone.querySelector('.status-confirm-btn').style.display = 'inline-block';
  clone.querySelector('.status-remove-btn').style.display = 'inline-block'; // Show remove for cancelling

  // Disable add button to prevent multiple new statuses
  document.getElementById('addButton').disabled = true;
}

function AddStatus(button) {
  console.log('AddStatus for ' + characterRep.name);
  const statusDiv = button.closest('.status-item');
  const inputElem = statusDiv.querySelector('.status-name-input');

  if (inputElem.value.trim() === '') {
    alert('Please enter a valid status.');
    return; // Exit if the input is empty
  }

  const statusName = inputElem.value.trim();

  // Check if a status with this name already exists
  if (characterRep.statuses) {
    const existingStatus = characterRep.statuses.find(status =>
      status.name.toLowerCase() === statusName.toLowerCase()
    );

    if (existingStatus) {
      alert(`A status with the name "${statusName}" already exists.`);
      return; // Exit if duplicate found
    }
  }

  // Get the duration value and unit
  const durationInput = statusDiv.querySelector('.status-duration-input');
  const unitSelect = statusDiv.querySelector('.status-unit-select');
  const durationValue = durationInput ? parseInt(durationInput.value) || 1 : 1;
  const unit = unitSelect ? unitSelect.value : 'rounds';

  // Convert duration to rounds
  const durationInRounds = convertToRounds(durationValue, unit);

  // Call server function to add status
  google.script.run
    .withSuccessHandler(onCharacterRepresentation)
    .withFailureHandler(function (error) {
      console.error('Error adding status:', error);
      alert('Error adding status: ' + error.message);
    })
    .AddStatusToCharacter(characterRep.docId, statusName, durationInRounds);

  document.getElementById('addButton').disabled = false;
}

function RemoveStatus(button, statusName) {
  const statusDiv = button.closest('.status-item');
  const confirmButton = statusDiv.querySelector('.status-confirm-btn');

  // If the confirm button exists and is visible, it's an unconfirmed row, so re-enable the add button.
  // If there's no confirm button, it means the status was already added, so we don't need to re-enable the add button.
  if (confirmButton && confirmButton.style.display !== 'none') {
    document.getElementById('addButton').disabled = false;
    statusDiv.remove();
    console.log('RemoveStatus for unconfirmed status');
    return;
  }

  // If we have a status name, call the server to remove it
  if (statusName) {
    google.script.run
      .withSuccessHandler(onCharacterRepresentation)
      .withFailureHandler(function (error) {
        console.error('Error removing status:', error);
        alert('Error removing status: ' + error.message);
      })
      .RemoveStatusFromCharacter(characterRep.docId, statusName);
  } else {
    // Fallback for cases where statusName is not provided
    statusDiv.remove();
    console.log('RemoveStatus for ' + characterRep.name);
  }
}

function PromprForPositiveInteger(message) {
  const amount = prompt(message, '1');

  // Check if user cancelled or entered invalid input
  if (amount === null || amount === '') {
    return { error: true, message: 'User cancelled' };
  }
  const result = parseInt(amount);
  if (isNaN(amount) || amount <= 0) {
    alert('Please enter a valid positive integer.');
    return { error: true, message: 'invalid input' };
  }

  return { error: false, result: result };
}

/**
 * Inflicts damage on the character
 * Prompts user for damage amount and calls server function
 */
function inflict() {
  // Prompt user for damage amount
  const promptResult = PromprForPositiveInteger(`How much damage to inflict on ${characterRep.name}?`);

  if (promptResult.error) {
    alert(promptResult.message);
    return;
  }
  const damageAmount = promptResult.result;

  console.log(`Inflicting ${damageAmount} damage to ${characterRep.name}`);

  // Call server-side function to inflict damage
  google.script.run
    .withSuccessHandler(onCharacterRepresentation)
    .withFailureHandler(function (error) {
      console.error('Error calling server function:', error);
      alert('Error inflicting damage: ' + error.message);
    })
    .UpdateHp(characterRep.docId, damageAmount, 'inflict');
}

function cure() {
  const promptResult = PromprForPositiveInteger(`How much damage to cure on ${characterRep.name}?`);
  if (promptResult.error) {
    alert(promptResult.message);
    return;
  }
  const damageAmount = promptResult.result;

  console.log(`Curing ${damageAmount} damage to ${characterRep.name}`);

  // Call server-side function to inflict damage
  google.script.run
    .withSuccessHandler(onCharacterRepresentation)
    .withFailureHandler(function (error) {
      console.error('Error calling server function:', error);
      alert('Error curing damage: ' + error.message);
    })
    .UpdateHp(characterRep.docId, damageAmount, 'cure');
}

function refreshCharacterData() {
  google.script.run
    .withSuccessHandler(onCharacterRepresentation)
    .withFailureHandler(function (error) {
      console.error('Error refreshing character data:', error);
    })
    .GetCharacterRepByDocId(characterRep.docId);

  // Update initiative, AC, attack bonus, and damage bonus
  document.getElementById('initBonus').innerHTML = characterRep.initBonus || '-';
  document.getElementById('acValue').innerHTML = characterRep.ac.currentScore || '-';

  console.log('Character data refreshed successfully');
}

/**
 * Handles the time passed button click
 */
function onTimePassed() {
  const amountInput = document.querySelector('.time-amount-input');
  const unitSelect = document.querySelector('.time-unit-select');

  const amount = amountInput ? parseInt(amountInput.value) || 1 : 1;
  const unit = unitSelect ? unitSelect.value : 'rounds';

  // Convert to rounds before sending to server
  const roundsElapsed = convertToRounds(amount, unit);

  console.log(`Time passing: ${amount} ${unit} (${roundsElapsed} rounds)`);

  // Call server function to handle time elapsed
  google.script.run
    .withSuccessHandler(onCharacterRepresentation)
    .withFailureHandler(function (error) {
      console.error('Error processing time elapsed:', error);
      alert('Error processing time elapsed: ' + error.message);
    })
    .OnRoundsElapsed(characterRep.docId, roundsElapsed);

  // Reset the input fields to default values
  if (amountInput) {
    amountInput.value = 1;
  }
  if (unitSelect) {
    unitSelect.value = 'rounds';
  }
}

/**
 * Populates the weapon dropdown with available weapons
 */
function populateWeaponDropdown() {
  const weaponSelect = document.getElementById('weaponSelect');
  const weapons = characterRep.weapons || [];

  // Clear existing options
  weaponSelect.innerHTML = '';

  if (weapons.length === 0) {
    weaponSelect.innerHTML = '<option value="">No weapons available</option>';
    return;
  }

  // Add default option
  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = 'Select a weapon...';
  weaponSelect.appendChild(defaultOption);

  // Add weapon options
  weapons.forEach((weapon, index) => {
    if (weapon && weapon.name) {
      const option = document.createElement('option');
      option.value = index;
      option.textContent = weapon.name;
      weaponSelect.appendChild(option);
    }
  });

  // Select first weapon by default if available
  if (weapons.length > 0) {
    weaponSelect.value = '0';
    onWeaponChange();
  }
}

/**
 * Handles weapon selection change and updates the displayed bonuses
 */
function onWeaponChange() {
  const weaponSelect = document.getElementById('weaponSelect');
  const selectedIndex = weaponSelect.value;

  console.log('Weapon changed to index:', selectedIndex);

  if (selectedIndex === '' || !characterRep.weapons || !characterRep.weapons[selectedIndex]) {
    document.getElementById('weaponAttackBonus').innerHTML = '-';
    document.getElementById('weaponDamageBonus').innerHTML = '-';
    return;
  }

  const selectedWeapon = characterRep.weapons[selectedIndex];

  // Update attack bonus
  UpdateValueAndTooltip('weaponAttackBonus', selectedWeapon.attackBonus);

  // Update damage bonus
  UpdateValueAndTooltip('weaponDamageBonus', selectedWeapon.damageBonus);

}

/**
 * Populates the special attack dropdown with available special attacks
 */
function populateSpecialAttackDropdown() {
  const specialAttackSelect = document.getElementById('specialAttackSelect');
  const specialAttacks = characterRep.specialAttacks || {};

  console.log('Populating special attack dropdown with attacks:', specialAttacks);

  // Clear existing options
  specialAttackSelect.innerHTML = '';

  const attackNames = Object.keys(specialAttacks);
  if (attackNames.length === 0) {
    specialAttackSelect.innerHTML = '<option value="">No special attacks available</option>';
    return;
  }

  // Add default option
  const defaultOption = document.createElement('option');
  defaultOption.value = '';
  defaultOption.textContent = 'Select a special attack...';
  specialAttackSelect.appendChild(defaultOption);

  // Add special attack options
  attackNames.forEach(attackName => {
    const option = document.createElement('option');
    option.value = attackName;
    option.textContent = attackName;
    specialAttackSelect.appendChild(option);
  });

  // Select first special attack by default if available
  if (attackNames.length > 0) {
    specialAttackSelect.value = attackNames[0];
    onSpecialAttackChange();
  }
}

/**
 * Handles special attack selection change and updates the displayed bonus
 */
function onSpecialAttackChange() {
  const specialAttackSelect = document.getElementById('specialAttackSelect');
  const selectedAttack = specialAttackSelect.value;

  console.log('Special attack changed to:', selectedAttack);

  if (selectedAttack === '' || !characterRep.specialAttacks || !characterRep.specialAttacks[selectedAttack]) {
    document.getElementById('specialAttackBonus').innerHTML = '-';
    return;
  }

  const selectedSpecialAttack = characterRep.specialAttacks[selectedAttack];

  // Update bonus
  UpdateValueAndTooltip('specialAttackBonus', selectedSpecialAttack);
}

</script>